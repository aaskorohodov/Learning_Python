'''Переворачивает словарь, то есть меняет местами ключи со значениями.
Есть проблема: значения в исходном словаре могут совпадать (видно ниже). Поэтому надо превращать значения в ключи,
а ключи складывать в список. Пример: {a:10, b:10} => {10:[a,b]}'''

my_dict = {'a':10, 'b':2, 'c':10}

def invert_dict(d):
    '''
    1. Создаем инвертированный словарь (пока пустой)
    2. Проходим по всем ключам исходного словаря
    3. setdefault возвращает значение по ключу, а если ключа нет, то создает такой ключ и (опционально) задает ему значение.
    Поэтому setdefault ставится на пустой словарь. Принимает d[key] – для нее это станет ключем, для исходного словаря (d)
    это напротив значение, то есть мы записываем значение в ключ. Вторым аргументом принимает пустой список, то есть
    этому ключу мы задаем значением пустой список, если этого ключа в новом словаре еще нет. Пример: записали 10 в ключи,
    значением положили пустой список, получили {10 : []}. Теперь питомагия: результатом setdefault яляется значение,
    то есть по только что заданному ключу 10 мы получаем пустой список, то есть конструкция inverse.setdefault(10, [])
    равняется пустому списку []. Поэтому можно обернуть все в .append и заполнить пустой список старым ключем.
    Если же в новом словаре такой ключ уже есть, то setdefault вернет его значение (переписывать список на пустой не будет),
    то есть вернет уже чем-то заполненный список (а в списке у нас буквы). И мы также дополним этот список с помощью .append еще одной буквой.
    4. Если это все слишком сложно, то #inverse[d[key]].append(key) делает все тоже самое, только дополнительным шагом.
    Тут мы обращаемся к значению нового словаря по ключу (который является значением старого словаря), чтобы получить значение
    нового словаря (а это пустой список), куда и записываем старый ключ.
    '''
    inverse = dict()
    for key in d:
        inverse.setdefault(d[key], []).append(key)
        #inverse[d[key]].append(key)
    return inverse

print(invert_dict(my_dict))