a = [['hello', 'hi'], ['what', 'no'], 100, ['yes']]


def capitalize_nested():
    '''Преобразует текст во вложенных список в заглавный.
    Сперва проверяет каждый объек родительского списка на (а список ли это?)(type == list)
    Затем для каждого объекта (т.е. слова) во вложенном списке делает object[object.index(eo)] = eo.upper(), что означает:
    ...объект с индексом[] = переопределить методом upper. Эквивалентно a = [1, 2] ... a[0] = 5 ... a = [5, 2],
    ...только обращаемся к объекту, который нужно заменить, посложнее.
    В [] указывается цифра, которая добывается, получением индекса нужного нам объека "object.index(eo)"
    Тут мы обращаемся ко вложенному списку по object, и просим дать индекс элемента eo. И вот этот индекс нам и нужен,
    чтобы заменить этот самый объект.'''
    for object in a:
        if type(object) == list:
            for eo in object:
                print(object[object.index(eo)])
                object[object.index(eo)] = eo.upper()
    return a



a = capitalize_nested()
print(a)


b = [[1,2], [3,4], 100, [5,6]]


def nested_sum():
    '''Похоже на функцию повыше, только также определяем тип вложенного объекта,
    только в конце заменяем его на сумму вложенного списка.
    Заводим переменную i, куда пишем индекс вложенного списка. Затем в summ пишем сумму вложенного списка.
    Затем в b по записанному индексу заносим сумму, и вот где интересно: если заносить сумму в [],
    то она заносится как список. Занести int в список методом list невозможно, так как list хочет что-либо перебирать,
    например строку, и заносит ее в списмок по буквам, а перебрать число он не может.
    Если проверить (type) вложенные списки, то они именно списки.'''
    for object in b:
        if type(object) == list:
            i = b.index(object)
            summ = sum(object)
            b[i] = [summ]
    print(b)
    print(type(b[0]))
nested_sum()