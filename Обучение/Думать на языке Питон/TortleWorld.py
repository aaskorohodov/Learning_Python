import math

from swampy.TurtleWorld import *
world = TurtleWorld()
bob = Turtle()
bob.delay = 0.5
print (bob)

def square(t, length):     #рисует квадрат, принимает Боба и длину стороны квадрата от пользователя
    for i in range(4):     #4 раза повторяет:
        fd(t, length)      #движение Боба вперед на переданную длину
        lt(t, 90)          #поворот на предварительно установленный градус (90, потому что это квадрат)

#square(bob, 100)

def poligon_my(t, length):                  #рисует полигон, вплоть до круга. Собственная разработка. Принимает длину прохода Боба (сколько бобу надо пройти до поворота)
    for i in range(int((360/length))):      #считает число повторов, исходя из длины прохода. Если длина прохода 120, то сделает треугольник, если 1, то сделает ровный круг.
        fd(t, length)                       #длина становится на свое место (сколько надо пройти Бобу)
        lt(t, length)                       #а также длина становится углом. Это ебанина, но она дает возможность нарисовать любой многоугольник вплоть до круга, используя минимум когда.
                                            #все остальные функции делать тоже самое, только более сложным образом.
#poligon_my(bob, length=90)

def polygon(t, n, length):                  #рисует многоугольник (полигон), принимает от пользователя число сторон (n) и длину прохода (размер многоугольника
    angle = 360.0 / n                       #высчитывает угол поворота для Боба, исходя из количества сторон полигона
    polyline(t, n, length, angle)           #вызывает полилайн, передавая ему высчитанный угол и все остальное (без изменений)


def circle(t, r):                           #рисует круг, принимает Боба и желаемый радиус круга от пользователя
    arc(t, r, 360)                          #вызывает арк. Единственная задача circle – передать угол в 360 градусов. Сам сиркл ничего не считает.

#circle(bob, 50)


def arc(t, r, angle):                                   #arc = дуга, то есть длина окружности, которую нарисует Боб. Можно нарисовать половину круга или любую другую длину. Принимает желаемый радиус и угол.
    arc_length = (2 * math.pi * r) * angle / 360        #считает длину дуги, исходя из радиуса и угла. Просто формула из учебника
    n = int(arc_length / 3) + 1                         #считает число сторон (круг строится из прямых линий, просто маленьких). Суть - сделать много сторон для большого круга и мало для маленькго, чтобы разрешение не падало.
    step_length = arc_length / n                        #считает длину прохода для Боба (длину каждой микро-стороны). Тоже нужно для улучшения разрешения.
    step_angle = float(angle) / n                       #считает угол поворота, исходя из нужного угла дуги (360 для круга или желаемый) и из количества сторон.
    polyline(t, n, step_length, step_angle)             #вызывает полилайн и передает туда Боба, число сторон (уже посчитанных, чтобы был круг), длину прохода и угол (и то и то тоже посчитанно, чтобы был круг с норм разрешщением)

#arc(bob, 50, 180)


def polyline(t, n, length, angle):          #принимает Боба, количество сторон, длину прохода и угол поворота
    """Чертит n линий заданной длины и угла.
    t - объект Боб"""
    for i in range(n):                      #приравнивает количество сторон к количествву итераций
        fd(t, length)                       #ставит длину на свое место
        lt(t, angle)                        #ставит угол на свое место
                                            #если это было вызванно полигоном, то полигон привносит только нужный угол поворота.




#arc(bob, 70, 180)
#polygon(bob, 360, 1)
#circle(bob, 100)
#help(polyline)


def polygon(t, length):
    angle = 360 / 3
    for i in range(3):
        fd(t, length)
        lt(t, angle)
    lt(t, 60)


def triagle_sizes(t, p, size):
    inner_angle = 360 / p
    a_angle = (180 - inner_angle) / 2
    side = (2 * size) * math.cos(math.radians(a_angle))
    for i in range(p):
        t_move(t,a_angle, side, size)


def t_move(t, a_angle, side, size):
    left_turn = 180 - a_angle
    fd(t, size)
    lt(t, left_turn)
    fd(t, side)
    lt(t, left_turn)
    fd(t, size)
    lt(t, 180)

triagle_sizes(bob, 10, 100)














wait_for_user()